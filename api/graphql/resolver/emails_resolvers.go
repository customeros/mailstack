package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"errors"
	"fmt"

	api_errors "github.com/customeros/mailstack/api/errors"
	"github.com/customeros/mailstack/api/graphql/graphql_model"
	"github.com/customeros/mailstack/api/graphql/mappers"
	"github.com/customeros/mailstack/internal/enum"
	"github.com/customeros/mailstack/internal/tracing"
	"github.com/customeros/mailstack/internal/utils"
	opentracing "github.com/opentracing/opentracing-go"
)

// SendEmail is the resolver for the sendEmail field.
func (r *mutationResolver) SendEmail(ctx context.Context, input graphql_model.EmailInput) (*graphql_model.EmailResult, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "queryResolver.SendEmail")
	defer span.Finish()
	tracing.SetDefaultGraphqlSpanTags(ctx, span)

	tenant := utils.GetTenantFromContext(ctx)
	if tenant == "" {
		tracing.TraceErr(span, errors.New("tenant not set"))
		return nil, api_errors.NewError("tenant not set", api_errors.CodeBadInput, nil)
	}
	userId := utils.GetUserIdFromContext(ctx)
	if userId == "" {
		tracing.TraceErr(span, errors.New("userId not set"))
		return nil, api_errors.NewError("usedId not set", api_errors.CodeBadInput, nil)
	}

	var result graphql_model.EmailResult
	emailID, emailStatus, err := r.services.EmailService.ScheduleSend(ctx, mappers.MapGraphEmailInputToGorm(&input), input.AttachmentIds)
	if err != nil {
		tracing.TraceErr(span, err)
		errStr := err.Error()
		result.Status = enum.EmailStatusFailed
		result.Error = &errStr
		return &result, err
	}

	result.EmailID = emailID
	result.Status = emailStatus

	return &result, nil
}

// GetAllEmailsInThread is the resolver for the getAllEmailsInThread field.
func (r *queryResolver) GetAllEmailsInThread(ctx context.Context, threadID string) ([]*graphql_model.EmailMessage, error) {
	panic(fmt.Errorf("not implemented: GetAllEmailsInThread - getAllEmailsInThread"))
}

// GetThreadMetadata is the resolver for the getThreadMetadata field.
func (r *queryResolver) GetThreadMetadata(ctx context.Context, threadID string) (*graphql_model.ThreadMetadata, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "queryResolver.GetThreadMetadata")
	defer span.Finish()
	tracing.SetDefaultGraphqlSpanTags(ctx, span)

	threadRecord, err := r.repositories.EmailThreadRepository.GetByID(ctx, threadID)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("error getting email thread", api_errors.CodeInternal, nil)
	}
	if threadRecord == nil {
		return nil, api_errors.NewError("thread not found", api_errors.CodeNotFound, nil)
	}

	attachments, err := r.repositories.EmailAttachmentRepository.ListByThread(ctx, threadRecord.ID)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("error getting email attachments", api_errors.CodeInternal, nil)
	}

	threadMetadata := &graphql_model.ThreadMetadata{
		ID: threadID,
		// TODO implement email thread summary
		Summary:        "This is a test email thread about testing",
		Participants:   threadRecord.Participants,
		HasAttachments: threadRecord.HasAttachments,
	}

	if attachments == nil || len(attachments) == 0 {
		return threadMetadata, nil
	}

	files := make([]*graphql_model.Attachment, 0, len(attachments))
	for _, attachment := range attachments {
		files = append(files, mappers.MapGormAttachmentToGraph(attachment))
	}

	threadMetadata.Attachments = files

	return threadMetadata, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *queryResolver) GetEmailsByThread(ctx context.Context, threadID string) ([]*graphql_model.EmailMessage, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "queryResolver.GetEmailsByThread")
	defer span.Finish()
	tracing.SetDefaultGraphqlSpanTags(ctx, span)

	emails, err := r.repositories.EmailRepository.ListByThread(ctx, threadID)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("error getting email thread", api_errors.CodeInternal, nil)
	}
	if emails == nil {
		return nil, api_errors.NewError("thread not found", api_errors.CodeNotFound, nil)
	}

	messages := make([]*graphql_model.EmailMessage, 0, len(emails))
	for _, email := range emails {
		message := mappers.MapGormEmailToGraph(email)
		attachments, err := r.repositories.EmailAttachmentRepository.ListByEmail(ctx, email.ID)
		if err != nil {
			tracing.TraceErr(span, err)
			return nil, api_errors.NewError("error getting attachment count", api_errors.CodeInternal, nil)
		}
		message.AttachmentCount = len(attachments)
		messages = append(messages, message)
	}

	return messages, nil
}
*/
