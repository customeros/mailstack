package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"

	api_errors "github.com/customeros/mailstack/api/errors"
	"github.com/customeros/mailstack/api/graphql/graphql_model"
	"github.com/customeros/mailstack/api/graphql/mappers"
	"github.com/customeros/mailstack/internal/tracing"
	opentracing "github.com/opentracing/opentracing-go"
)

// SendEmail is the resolver for the sendEmail field.
func (r *mutationResolver) SendEmail(ctx context.Context, input graphql_model.EmailInput) (*graphql_model.EmailResult, error) {
	panic(fmt.Errorf("not implemented: SendEmail - sendEmail"))
}

// GetEmailsByThread is the resolver for the getEmailsByThread field.
func (r *queryResolver) GetEmailsByThread(ctx context.Context, threadID string) ([]*graphql_model.EmailMessage, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "queryResolver.GetEmailsByThread")
	defer span.Finish()
	tracing.SetDefaultGraphqlSpanTags(ctx, span)

	emails, err := r.repositories.EmailRepository.ListByThread(ctx, threadID)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("error getting email thread", api_errors.CodeInternal, nil)
	}
	if emails == nil {
		return nil, api_errors.NewError("thread not found", api_errors.CodeNotFound, nil)
	}

	messages := make([]*graphql_model.EmailMessage, 0, len(emails))
	for _, email := range emails {
		message := mappers.MapGormEmailToGraph(email)
		attachments, err := r.repositories.EmailAttachmentRepository.ListByEmail(ctx, email.ID)
		if err != nil {
			tracing.TraceErr(span, err)
			return nil, api_errors.NewError("error getting attachment count", api_errors.CodeInternal, nil)
		}
		message.AttachmentCount = len(attachments)
		messages = append(messages, message)
	}

	return messages, nil
}

// GetThreadMetadata is the resolver for the getThreadMetadata field.
func (r *queryResolver) GetThreadMetadata(ctx context.Context, threadID string) (*graphql_model.ThreadMetadata, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "queryResolver.GetThreadMetadata")
	defer span.Finish()
	tracing.SetDefaultGraphqlSpanTags(ctx, span)

	threadRecord, err := r.repositories.EmailThreadRepository.GetByID(ctx, threadID)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("error getting email thread", api_errors.CodeInternal, nil)
	}
	if threadRecord == nil {
		return nil, api_errors.NewError("thread not found", api_errors.CodeNotFound, nil)
	}

	attachments, err := r.repositories.EmailAttachmentRepository.ListByThread(ctx, threadRecord.ID)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("error getting email attachments", api_errors.CodeInternal, nil)
	}

	threadMetadata := &graphql_model.ThreadMetadata{
		ID: threadID,
		// TODO implement email thread summary
		Summary:        "This is a test email thread about testing",
		Participants:   threadRecord.Participants,
		HasAttachments: threadRecord.HasAttachments,
	}

	if attachments == nil || len(attachments) == 0 {
		return threadMetadata, nil
	}

	files := make([]*graphql_model.Attachment, 0, len(attachments))
	for _, attachment := range attachments {
		files = append(files, mappers.MapGormAttachmentToGraph(attachment))
	}

	threadMetadata.Attachments = files

	return threadMetadata, nil
}
