package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"

	"github.com/opentracing/opentracing-go"

	api_errors "github.com/customeros/mailstack/api/errors"
	"github.com/customeros/mailstack/api/graphql/graphql_model"
	"github.com/customeros/mailstack/api/graphql/mappers"
	"github.com/customeros/mailstack/internal/tracing"
)

// GetAllThreads is the resolver for the getAllThreads field.
func (r *queryResolver) GetAllThreads(ctx context.Context, userID string, pagination *graphql_model.PaginationInput) (*graphql_model.EmailThreadConnection, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "queryResolver.GetAllThreads")
	defer span.Finish()
	tracing.SetDefaultGraphqlSpanTags(ctx, span)

	// Set default pagination if not provided
	limit := 50
	offset := 0

	if pagination != nil {
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil {
			offset = *pagination.Offset
		}
	}

	// Get all mailboxes for userID
	mailboxes, err := r.repositories.MailboxRepository.GetMailboxesByUserID(ctx, userID)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("unable to get mailboxes for user", api_errors.CodeInternal, nil)
	}
	if mailboxes == nil {
		return nil, api_errors.NewError("no mailboxes found for user", api_errors.CodeNotFound, nil)
	}

	mailboxIds := make([]string, 0, len(mailboxes))
	for _, mailbox := range mailboxes {
		mailboxIds = append(mailboxIds, mailbox.ID)
	}

	// Get total count for pageInfo
	totalCount, err := r.repositories.EmailThreadRepository.CountByMailboxIDs(ctx, mailboxIds)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("no threads found for user", api_errors.CodeNotFound, nil)
	}

	// Get paginated threads
	threads, err := r.repositories.EmailThreadRepository.GetByMailboxIDs(ctx, mailboxIds, limit, offset)
	if err != nil {
		tracing.TraceErr(span, err)
		return nil, api_errors.NewError("unable to retreive threads for user", api_errors.CodeNotFound, nil)
	}
	if threads == nil {
		return nil, api_errors.NewError("no threads found", api_errors.CodeNotFound, nil)
	}

	var apiThreads []*graphql_model.EmailThread
	for _, thread := range threads {
		mappedThread := mappers.MapGormThreadToGraph(thread)
		mappedThread.UserID = userID

		email, err := r.repositories.EmailRepository.GetByID(ctx, thread.LastMessageID)
		if err != nil {
			tracing.TraceErr(span, err)
			return nil, api_errors.NewError("unable to retrieve email", api_errors.CodeInternal, nil)
		}
		if email == nil {
			return nil, api_errors.NewError("no email found", api_errors.CodeNotFound, nil)
		}

		mappedThread.LastSender = email.FromAddress
		mappedThread.LastSenderDomain = email.FromDomain
		apiThreads = append(apiThreads, mappedThread)
	}

	// Calculate pagination info
	hasNextPage := offset+len(threads) < int(totalCount)
	hasPreviousPage := offset > 0

	return &graphql_model.EmailThreadConnection{
		Edges:      apiThreads,
		TotalCount: int(totalCount),
		PageInfo: &graphql_model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
		},
	}, nil
}
